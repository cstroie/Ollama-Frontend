<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
      <title>Ollama WebUI Chat</title>
      <style>
         * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
         }

         :root {
            --primary-bg: #f5f5f7;
            --secondary-bg: #ffffff;
            --accent-bg: #007aff;
            --accent-hover: #0056b3;
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;
            --border-color: #e5e5e7;
            --hover-bg: #f0f0f2;
            --error-bg: #ff3b30;
            --success-bg: #34c759;
            --warning-bg: #ff9500;
            --terminal-bg: #2d2d2d;
            --terminal-text: #d4d4d4;
            --shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            --shadow-light: 0 2px 8px rgba(0, 0, 0, 0.05);
            --shadow-heavy: 0 8px 32px rgba(0, 0, 0, 0.15);
            --radius: 12px;
            --radius-small: 8px;
         }

         [data-theme="dark"] {
            --primary-bg: #1a1a1e;
            --secondary-bg: #2a2a2e;
            --accent-bg: #0d6efd;
            --accent-hover: #0b5ed7;
            --text-primary: #f8f9fa;
            --text-secondary: #adb5bd;
            --border-color: #3a3a3e;
            --hover-bg: #3a3a3e;
            --error-bg: #dc3545;
            --success-bg: #198754;
            --warning-bg: #ffc107;
            --terminal-bg: #2d2d2d;
            --terminal-text: #e9ecef;
            --shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            --shadow-light: 0 2px 8px rgba(0, 0, 0, 0.2);
            --shadow-heavy: 0 8px 32px rgba(0, 0, 0, 0.4);
         }

         body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.5;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
         }

         .app-container {
            display: flex;
            height: 100vh;
            max-width: 1400px;
            margin: 0 auto;
            background: var(--secondary-bg);
            overflow: hidden;
         }

         .sidebar {
            width: 280px;
            background: var(--primary-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            position: relative;
            z-index: 100;
         }

         .sidebar-toggle {
            display: none;
            position: absolute;
            right: -40px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: var(--accent-bg);
            color: white;
            border: none;
            border-radius: 0 var(--radius-small) var(--radius-small) 0;
            cursor: pointer;
            font-size: 20px;
            z-index: 101;
         }

         .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
         }

         .logo {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-bg);
            margin-bottom: 16px;
         }

         .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 8px 12px;
            border-radius: var(--radius-small);
            margin-bottom: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
         }

         .status-indicator.connected {
            background: #d4edda;
            color: #155724;
         }

         [data-theme="dark"] .status-indicator.connected {
            background: #28a745;
            color: #ffffff;
         }

         .status-indicator.disconnected {
            background: #f8d7da;
            color: #721c24;
         }

         [data-theme="dark"] .status-indicator.disconnected {
            background: #dc3545;
            color: #ffffff;
         }

         .status-indicator.saving {
            background: #fff3cd;
            color: #856404;
         }

         [data-theme="dark"] .status-indicator.saving {
            background: #ffc107;
            color: #000000;
         }

         .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
         }

         .model-selector {
            position: relative;
         }

         .model-select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            background: var(--secondary-bg);
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
         }

         .model-select:hover {
            border-color: var(--accent-bg);
         }

         .model-select:focus {
            outline: none;
            border-color: var(--accent-bg);
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25);
         }

         .chat-list {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
         }

         .chat-item {
            padding: 12px 16px;
            margin-bottom: 8px;
            border-radius: var(--radius-small);
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--secondary-bg);
            border: 1px solid transparent;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-primary);
         }

         .chat-item:hover {
            background: var(--hover-bg);
            border-color: var(--border-color);
         }

         .chat-item.active {
            background: var(--accent-bg);
            color: white;
            border-color: var(--accent-bg);
         }

         .chat-content {
            flex: 1;
            min-width: 0;
         }

         .chat-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
         }

         .chat-preview {
            font-size: 12px;
            opacity: 0.7;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
         }

         [data-theme="dark"] .chat-preview {
            opacity: 0.8;
         }

         .chat-delete {
            opacity: 0;
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 16px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
         }

         .chat-item:hover .chat-delete {
            opacity: 0.7;
         }

         .chat-delete:hover {
            opacity: 1 !important;
            background: rgba(255, 255, 255, 0.2);
         }

         .new-chat-btn {
            margin: 16px;
            padding: 12px 16px;
            background: var(--accent-bg);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
         }

         .new-chat-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
         }

         .theme-toggle .theme-icon {
            font-size: 16px;
         }

         .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
         }

         .chat-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--secondary-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
         }

         .chat-title-header {
            font-size: 18px;
            font-weight: 600;
            flex: 1;
            min-width: 200px;
         }

         .header-controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
         }

         .control-btn {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            background: var(--secondary-bg);
            border-radius: var(--radius-small);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            white-space: nowrap;
            color: var(--text-primary);
         }

         .control-btn:hover {
            background: var(--hover-bg);
            border-color: var(--accent-bg);
         }

         .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: var(--primary-bg);
         }

         .message {
            margin-bottom: 24px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
         }

         .message.user {
            flex-direction: row-reverse;
         }

         .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
         }

         .message.user .message-avatar {
            background: var(--accent-bg);
            color: white;
         }

         .message.assistant .message-avatar {
            background: var(--text-secondary);
            color: white;
         }

         [data-theme="dark"] .message.assistant .message-avatar {
            background: #6c757d;
         }

         .message-content {
            max-width: 70%;
            padding: 16px 20px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-light);
            position: relative;
            word-wrap: break-word;
         }

         .message.user .message-content {
            background: var(--accent-bg);
            color: white;
            border-bottom-right-radius: 4px;
         }

         .message.assistant .message-content {
            background: var(--secondary-bg);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
         }

         .message-text {
            line-height: 1.6;
         }

         .message-time {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 8px;
         }

         .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: inherit;
            opacity: 0;
            transition: opacity 0.2s, background-color 0.3s ease;
         }

         .message-content:hover .copy-btn {
            opacity: 0.7;
         }

         .copy-btn:hover {
            opacity: 1 !important;
            background: rgba(0, 0, 0, 0.2);
         }

         [data-theme="dark"] .message.user .copy-btn {
            background: rgba(255, 255, 255, 0.1);
         }

         [data-theme="dark"] .message.user .copy-btn:hover {
            background: rgba(255, 255, 255, 0.2);
         }

         .input-container {
            padding: 20px;
            background: var(--secondary-bg);
            border-top: 1px solid var(--border-color);
         }

         .input-wrapper {
            display: flex;
            gap: 12px;
            align-items: flex-end;
            max-width: 100%;
         }

         .message-input {
            flex: 1;
            min-height: 44px;
            max-height: 120px;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            resize: none;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.4;
            background: var(--primary-bg);
            color: var(--text-primary);
            transition: all 0.2s ease;
         }

         .message-input:focus {
            outline: none;
            border-color: var(--accent-bg);
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25);
         }

         .message-input::placeholder {
            color: var(--text-secondary);
         }

         [data-theme="dark"] .message-input::placeholder {
            color: #6c757d;
         }

         .send-btn,
         .stop-btn {
            width: 44px;
            height: 44px;
            border: none;
            background: var(--accent-bg);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 18px;
         }

         .stop-btn {
            background: var(--error-bg);
         }

         .send-btn:hover:not(:disabled),
         .stop-btn:hover {
            transform: scale(1.05);
         }

         .send-btn:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
         }

         .streaming-cursor {
            display: inline-block;
            background: var(--accent-bg);
            color: white;
            margin-left: 2px;
            animation: blink 1s infinite;
            font-weight: normal;
            padding: 0 2px;
         }

         .message.assistant .streaming-cursor {
            background: var(--text-primary);
            color: var(--secondary-bg);
         }

         @keyframes blink {
            0%, 50% {
               opacity: 1;
            }
            51%, 100% {
               opacity: 0;
            }
         }

         .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(245, 245, 247, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: background-color 0.3s ease;
         }

         [data-theme="dark"] .loading-overlay {
            background: rgba(26, 26, 30, 0.9);
         }

         .loading-content {
            text-align: center;
            padding: 32px;
            background: var(--secondary-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            color: var(--text-primary);
         }

         .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-bg);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
         }

         @keyframes spin {
            0% {
               transform: rotate(0deg);
            }
            100% {
               transform: rotate(360deg);
            }
         }

         .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 1000;
            animation: modalFadeIn 0.2s ease-out;
         }

         .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
         }

         @keyframes modalFadeIn {
            from {
               opacity: 0;
               backdrop-filter: blur(0px);
            }
            to {
               opacity: 1;
               backdrop-filter: blur(10px);
            }
         }

         .modal-content {
            background: var(--secondary-bg);
            padding: 32px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-heavy);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            transform: scale(0.9);
            animation: modalSlideIn 0.2s ease-out forwards;
         }

         @keyframes modalSlideIn {
            from {
               transform: scale(0.9) translateY(-20px);
               opacity: 0;
            }
            to {
               transform: scale(1) translateY(0);
               opacity: 1;
            }
         }

         .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 24px;
         }

         .setting-group {
            margin-bottom: 20px;
         }

         .setting-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
         }

         .setting-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            font-size: 14px;
            background: var(--primary-bg);
            color: var(--text-primary);
            transition: all 0.2s ease;
         }

         .setting-input:focus {
            outline: none;
            border-color: var(--accent-bg);
            box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25);
         }

         .setting-help {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
         }

         .connection-diagnostics {
            background: var(--primary-bg);
            padding: 12px;
            border-radius: var(--radius-small);
            border: 1px solid var(--border-color);
            margin-bottom: 16px;
            color: var(--text-primary);
         }

         .diagnostic-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 14px;
         }

         .diagnostic-item:last-child {
            margin-bottom: 0;
         }

         .diagnostic-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
         }

         .diagnostic-status.success {
            background: var(--success-bg);
         }

         .diagnostic-status.error {
            background: var(--error-bg);
         }

         .diagnostic-status.warning {
            background: var(--warning-bg);
         }

         .troubleshooting-section {
            background: var(--primary-bg);
            padding: 16px;
            border-radius: var(--radius-small);
            border: 1px solid var(--border-color);
         }

         .troubleshooting-steps .step {
            margin-bottom: 16px;
         }

         .troubleshooting-steps .step:last-child {
            margin-bottom: 0;
         }

         .code-snippet {
            background: var(--terminal-bg);
            color: var(--terminal-text);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 13px;
            margin-top: 4px;
            user-select: all;
            cursor: pointer;
         }

         .code-snippet:hover {
            background: #2d2d2d;
         }

         [data-theme="dark"] .code-snippet:hover {
            background: #1a1a1a;
         }

         .model-management {
            background: var(--primary-bg);
            padding: 16px;
            border-radius: var(--radius-small);
            border: 1px solid var(--border-color);
         }

         .model-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 16px;
         }

         .model-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            margin-bottom: 8px;
            color: var(--text-primary);
         }

         .model-info {
            flex: 1;
         }

         .model-name {
            font-weight: 600;
            font-size: 14px;
         }

         .model-size {
            font-size: 12px;
            color: var(--text-secondary);
         }

         .model-actions {
            display: flex;
            gap: 8px;
         }

         .model-btn {
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            background: var(--secondary-bg);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            color: var(--text-primary);
         }

         .model-btn.danger {
            border-color: var(--error-bg);
            color: var(--error-bg);
         }

         .model-btn.danger:hover {
            background: var(--error-bg);
            color: white;
         }

         .model-btn:hover {
            background: var(--hover-bg);
         }

         .add-model-section {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
         }

         .add-model-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            font-size: 14px;
            background: var(--primary-bg);
            color: var(--text-primary);
         }

         .add-model-btn {
            padding: 8px 16px;
            background: var(--success-bg);
            color: white;
            border: none;
            border-radius: var(--radius-small);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            white-space: nowrap;
         }

         .add-model-btn:hover {
            background: #28a745;
         }

         .add-model-btn:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
         }

         .terminal {
            display: none;
            background: var(--terminal-bg);
            color: var(--terminal-text);
            padding: 16px;
            border-radius: var(--radius-small);
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 16px;
            border: 1px solid var(--border-color);
         }

         .terminal.visible {
            display: block;
         }

         .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
         }

         .terminal-title {
            color: #fff;
            font-weight: 600;
         }

         .terminal-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
         }

         .terminal-close:hover {
            color: #fff;
         }

         .terminal-output {
            white-space: pre-wrap;
            word-wrap: break-word;
         }

         .terminal-line {
            margin-bottom: 4px;
         }

         .terminal-line.success {
            color: var(--success-bg);
         }

         .terminal-line.error {
            color: #ff6b6b;
         }

         .terminal-line.warning {
            color: var(--warning-bg);
         }

         .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
            flex-wrap: wrap;
         }

         .modal-btn {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-small);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            background: var(--secondary-bg);
            color: var(--text-primary);
         }

         .modal-btn.primary {
            background: var(--accent-bg);
            color: white;
            border-color: var(--accent-bg);
         }

         .modal-btn.danger {
            background: var(--error-bg);
            color: white;
            border-color: var(--error-bg);
         }

         .modal-btn.success {
            background: var(--success-bg);
            color: white;
            border-color: var(--success-bg);
         }

         .modal-btn:hover {
            background: var(--hover-bg);
            transform: translateY(-1px);
         }

         .modal-btn.primary:hover {
            background: var(--accent-hover);
         }

         .modal-btn.danger:hover {
            background: #d32f2f;
         }

         .modal-btn.success:hover {
            background: #28a745;
         }

         .code-block {
            background: var(--terminal-bg);
            color: var(--terminal-text);
            padding: 16px;
            border-radius: var(--radius-small);
            margin: 8px 0;
            overflow-x: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
         }

         .inline-code {
            background: var(--hover-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 13px;
            color: var(--text-primary);
         }

         .notification-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 3000;
            animation: modalFadeIn 0.2s ease-out;
         }

         .notification-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
         }

         .notification-content {
            background: var(--secondary-bg);
            padding: 24px 32px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-heavy);
            width: 90%;
            max-width: 600px;
            text-align: center;
            transform: scale(0.9);
            animation: modalSlideIn 0.2s ease-out forwards;
            color: var(--text-primary);
         }

         .notification-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-size: 24px;
            font-weight: 600;
         }

         .notification-icon.success {
            background: var(--success-bg);
            color: white;
         }

         .notification-icon.error {
            background: var(--error-bg);
            color: white;
         }

         .notification-icon.warning {
            background: var(--warning-bg);
            color: white;
         }

         .notification-icon.info {
            background: var(--accent-bg);
            color: white;
         }

         .notification-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
         }

         .notification-message {
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            margin-bottom: 24px;
            white-space: pre-wrap;
         }

         .notification-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
         }

         .confirmation-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 3000;
            animation: modalFadeIn 0.2s ease-out;
         }

         .confirmation-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
         }

         .confirmation-content {
            background: var(--secondary-bg);
            padding: 24px 32px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-heavy);
            width: 90%;
            max-width: 500px;
            text-align: center;
            transform: scale(0.9);
            animation: modalSlideIn 0.2s ease-out forwards;
            color: var(--text-primary);
         }

         .confirmation-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-size: 24px;
            font-weight: 600;
            background: var(--warning-bg);
            color: white;
         }

         .confirmation-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
         }

         .confirmation-message {
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
            margin-bottom: 24px;
         }

         .confirmation-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
         }

         .error-message {
            background: var(--error-bg);
            color: white;
            padding: 12px 16px;
            border-radius: var(--radius-small);
            margin: 16px;
            text-align: center;
         }

         @media (max-width: 768px) {
            .app-container {
               border-radius: 0;
            }

            .sidebar {
               position: fixed;
               left: -280px;
               height: 100%;
               box-shadow: var(--shadow-heavy);
            }

            .sidebar.open {
               transform: translateX(280px);
            }

            .sidebar-toggle {
               display: block;
            }

            .main-content {
               width: 100%;
            }

            .message-content {
               max-width: 85%;
            }

            .chat-header {
               padding: 15px;
            }

            .chat-title-header {
               font-size: 16px;
            }

            .header-controls {
               width: 100%;
               justify-content: space-between;
            }

            .control-btn {
               flex: 1;
               text-align: center;
            }

            .messages-container {
               padding: 15px;
            }

            .input-container {
               padding: 15px;
            }

            .modal-content,
            .notification-content,
            .confirmation-content {
               width: 95%;
               padding: 20px;
            }

            .model-actions {
               flex-direction: column;
               gap: 4px;
            }

            .add-model-section {
               flex-direction: column;
            }

            .add-model-input {
               width: 100%;
            }

            .add-model-btn {
               width: 100%;
            }
         }

         @media (max-width: 480px) {
            .message-content {
               max-width: 90%;
            }

            .message-avatar {
               width: 32px;
               height: 32px;
               font-size: 12px;
            }

            .logo {
               font-size: 20px;
            }

            .chat-title-header {
               font-size: 14px;
            }
         }

         @media (min-width: 1400px) {
            .app-container {
               border-radius: var(--radius);
            }

            .messages-container {
               padding: 30px;
            }

            .message-content {
               max-width: 60%;
            }
         }
      </style>
   </head>
   <body>
      <div class="loading-overlay" id="loadingOverlay">
         <div class="loading-content">
            <div class="loading-spinner"></div>
            <div id="loadingText">Initializing application...</div>
         </div>
      </div>
      <div class="app-container">
         <div class="sidebar" id="sidebar">
            <button class="sidebar-toggle" id="sidebarToggle">☰</button>
            <div class="sidebar-header">
               <div class="logo">Ollama Chat</div>
               <div class="status-indicator" id="statusIndicator">
                  <div class="status-dot"></div>
                  <span id="statusText">Connecting...</span>
               </div>
               <div class="model-selector">
                  <select class="model-select" id="modelSelect">
                     <option value="">Select Model...</option>
                  </select>
               </div>
            </div>
            <div class="chat-list" id="chatList"></div>
            <button class="new-chat-btn" id="newChatBtn">+ New Chat</button>
         </div>
         <div class="main-content">
            <div class="chat-header">
               <div class="chat-title-header" id="chatTitle">Welcome to Ollama WebUI Chat</div>
               <div class="header-controls">
                  <button class="control-btn theme-toggle" id="themeToggle">
                     <span class="theme-icon" id="themeIcon">🌙</span>
                     <span>Dark Mode</span>
                  </button>
                  <button class="control-btn" id="clearChatBtn">Clear Chat</button>
                  <button class="control-btn" id="settingsBtn">Settings</button>
               </div>
            </div>
            <div class="messages-container" id="messagesContainer">
               <div class="message assistant">
                  <div class="message-avatar">AI</div>
                  <div class="message-content">
                     <div class="message-text">Hello! I'm your AI assistant. Please select a model from the sidebar to start chatting.</div>
                     <div class="message-time">Just now</div>
                  </div>
               </div>
            </div>
            <div class="input-container">
               <div class="input-wrapper">
                  <textarea class="message-input" id="messageInput" placeholder="Type your message here..." rows="1"></textarea>
                  <button class="send-btn" id="sendBtn">➤</button>
               </div>
            </div>
         </div>
      </div>
      <div class="modal" id="settingsModal">
         <div class="modal-content">
            <div class="modal-header">Settings</div>
            <div class="setting-group">
               <div class="connection-status-section">
                  <h4 style="margin-bottom:12px;color:var(--text-primary)">Connection Status</h4>
                  <div id="connectionDiagnostics" class="connection-diagnostics"></div>
               </div>
            </div>
            <div class="setting-group">
               <h4 style="margin-bottom:12px;color:var(--text-primary)">Model Management</h4>
               <div class="model-management">
                  <div class="add-model-section">
                     <input type="text" class="add-model-input" id="addModelInput" placeholder="Enter model name (e.g., llama2, codellama, mistral)">
                     <button class="add-model-btn" id="addModelBtn">Pull Model</button>
                  </div>
                  <div class="model-list" id="modelList"></div>
                  <div class="terminal" id="terminal">
                     <div class="terminal-header">
                        <div class="terminal-title">Model Operation Progress</div>
                        <button class="terminal-close" id="terminalClose">×</button>
                     </div>
                     <div class="terminal-output" id="terminalOutput"></div>
                  </div>
               </div>
            </div>
            <div class="setting-group">
               <label class="setting-label" for="ollamaUrl">Ollama Server URL</label>
               <input type="text" class="setting-input" id="ollamaUrl" value="http://localhost:11434">
               <div class="setting-help">Default: http://localhost:11434</div>
            </div>
            <div class="setting-group">
               <label class="setting-label" for="temperature">Temperature (0-2)</label>
               <input type="number" class="setting-input" id="temperature" min="0" max="2" step="0.1" value="0.7">
               <div class="setting-help">Controls randomness. Lower = more focused, Higher = more creative</div>
            </div>
            <div class="setting-group">
               <label class="setting-label" for="topP">Top P (0-1)</label>
               <input type="number" class="setting-input" id="topP" min="0" max="1" step="0.1" value="0.9">
               <div class="setting-help">Nucleus sampling. Lower = more focused responses</div>
            </div>
            <div class="setting-group">
               <div class="troubleshooting-section">
                  <h4 style="margin-bottom:12px;color:var(--text-primary)">Troubleshooting (Linux)</h4>
                  <div class="troubleshooting-steps">
                     <div class="step">
                        <strong>1. Start Ollama with CORS enabled:</strong>
                        <div class="code-snippet">export OLLAMA_ORIGINS=&quot;*&quot; &amp;&amp; ollama serve</div>
                     </div>
                     <div class="step">
                        <strong>2. Or set environment variable permanently:</strong>
                        <div class="code-snippet">echo 'export OLLAMA_ORIGINS="*"' &gt;&gt; ~/.bashrc</div>
                        <div class="code-snippet">source ~/.bashrc</div>
                     </div>
                     <div class="step">
                        <strong>3. Verify Ollama is running:</strong>
                        <div class="code-snippet">curl http://localhost:11434/api/tags</div>
                     </div>
                     <div class="step">
                        <strong>4. Pull a model manually:</strong>
                        <div class="code-snippet">ollama pull gemma3:1b</div>
                     </div>
                  </div>
               </div>
            </div>
            <div class="modal-actions">
               <button class="modal-btn" id="testConnectionBtn">Test Connection</button>
               <button class="modal-btn" id="cancelSettingsBtn">Cancel</button>
               <button class="modal-btn primary" id="saveSettingsBtn">Save</button>
            </div>
         </div>
      </div>
      <div class="notification-modal" id="notificationModal">
         <div class="notification-content">
            <div class="notification-icon" id="notificationIcon">!</div>
            <div class="notification-title" id="notificationTitle">Notification</div>
            <div class="notification-message" id="notificationMessage">Message</div>
            <div class="notification-actions">
               <button class="modal-btn primary" id="notificationOkBtn">OK</button>
            </div>
         </div>
      </div>
      <div class="confirmation-modal" id="confirmationModal">
         <div class="confirmation-content">
            <div class="confirmation-icon">?</div>
            <div class="confirmation-title" id="confirmationTitle">Confirm Action</div>
            <div class="confirmation-message" id="confirmationMessage">Are you sure?</div>
            <div class="confirmation-actions">
               <button class="modal-btn" id="confirmationCancelBtn">Cancel</button>
               <button class="modal-btn danger" id="confirmationConfirmBtn">Confirm</button>
            </div>
         </div>
      </div>
      <script>
         /**
          * Main application class for the Ollama WebUI Chat
          * Manages chat state, IndexedDB storage, UI updates, and Ollama API interactions
          */
         class OllamaChatApp {
            /**
             * Initialize the application state and configuration
             */
            constructor() {
               this.db = null;                           // IndexedDB database instance
               this.streamingUpdateThrottle = false;     // Throttle flag for streaming updates
               this.lastStreamingUpdate = 0;             // Last streaming update timestamp
               this.currentStream = null;                // Current fetch stream controller
               this.eventListeners = new Map();          // Track event listeners for cleanup
               this.state = {
                  currentChatId: null,                   // ID of currently active chat
                  chats: {},                             // In-memory cache of all chats
                  models: [],                            // Available Ollama models
                  selectedModel: '',                     // Currently selected model
                  settings: {
                     ollamaUrl: 'http://localhost:11434', // Ollama API endpoint
                     temperature: 0.7,                    // Model temperature setting (0-2)
                     topP: 0.9                            // Model top-p setting (0-1)
                  },
                  isConnected: false,                    // Connection status to Ollama
                  connectionError: null,                 // Detailed connection error info
                  isStreaming: false,                    // Whether a response is streaming
                  theme: 'light'                         // UI theme ('light' or 'dark')
               };
               this.DB_NAME = 'OllamaChatDB';            // IndexedDB database name
               this.DB_VERSION = 1;                      // IndexedDB schema version
            }
            /**
             * Display a notification modal to the user
             * @param {string} type - Notification type ('success', 'error', 'warning', 'info')
             * @param {string} title - Notification title
             * @param {string} message - Notification message content
             * @returns {Promise} Resolves when notification is closed
             */
            showNotification(type, title, message) {
               return new Promise((resolve) => {
                  const modal = document.getElementById('notificationModal');
                  const icon = document.getElementById('notificationIcon');
                  const titleEl = document.getElementById('notificationTitle');
                  const messageEl = document.getElementById('notificationMessage');
                  const okBtn = document.getElementById('notificationOkBtn');

                  // Set icon based on notification type
                  icon.className = `notification-icon ${type}`;
                  switch (type) {
                     case 'success':
                        icon.textContent = '✔';
                        break;
                     case 'error':
                        icon.textContent = '✕';
                        break;
                     case 'warning':
                        icon.textContent = '⚠';
                        break;
                     default:
                        icon.textContent = 'ℹ';
                  }

                  // Update modal content
                  titleEl.textContent = title;
                  messageEl.textContent = message;
                  this.showModal('notificationModal');

                  // Handle close button click
                  const handleClose = () => {
                     this.hideModal('notificationModal');
                     okBtn.removeEventListener('click', handleClose);
                     resolve();
                  };
                  okBtn.addEventListener('click', handleClose);
               });
            }
            /**
             * Display a confirmation modal to the user
             * @param {string} title - Confirmation dialog title
             * @param {string} message - Confirmation message content
             * @returns {Promise<boolean>} Resolves with true if confirmed, false if cancelled
             */
            showConfirmation(title, message) {
               return new Promise((resolve) => {
                  const modal = document.getElementById('confirmationModal');
                  const titleEl = document.getElementById('confirmationTitle');
                  const messageEl = document.getElementById('confirmationMessage');
                  const cancelBtn = document.getElementById('confirmationCancelBtn');
                  const confirmBtn = document.getElementById('confirmationConfirmBtn');

                  // Update modal content
                  titleEl.textContent = title;
                  messageEl.textContent = message;
                  this.showModal('confirmationModal');

                  // Handle cancel button click
                  const handleCancel = () => {
                     this.hideModal('confirmationModal');
                     cancelBtn.removeEventListener('click', handleCancel);
                     confirmBtn.removeEventListener('click', handleConfirm);
                     resolve(false);
                  };

                  // Handle confirm button click
                  const handleConfirm = () => {
                     this.hideModal('confirmationModal');
                     cancelBtn.removeEventListener('click', handleCancel);
                     confirmBtn.removeEventListener('click', handleConfirm);
                     resolve(true);
                  };

                  cancelBtn.addEventListener('click', handleCancel);
                  confirmBtn.addEventListener('click', handleConfirm);
               });
            }
            /**
             * Initialize IndexedDB database with required object stores
             * @returns {Promise<IDBDatabase>} Resolves with the database instance
             */
            async initDB() {
               return new Promise((resolve, reject) => {
                  const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                  request.onerror = () => reject(new Error('Failed to open database'));

                  request.onsuccess = () => {
                     this.db = request.result;
                     resolve(this.db);
                  };

                  // Create database schema on first run or version upgrade
                  request.onupgradeneeded = (event) => {
                     this.db = event.target.result;

                     // Create chats store with id as key and createdAt index
                     if (!this.db.objectStoreNames.contains('chats')) {
                        const chatStore = this.db.createObjectStore('chats', { keyPath: 'id' });
                        chatStore.createIndex('createdAt', 'createdAt', { unique: false });
                        // Add model index for better querying
                        chatStore.createIndex('model', 'model', { unique: false });
                     }

                     // Create settings store with key as primary key
                     if (!this.db.objectStoreNames.contains('settings')) {
                        this.db.createObjectStore('settings', { keyPath: 'key' });
                     }

                     // Create appState store for session persistence
                     if (!this.db.objectStoreNames.contains('appState')) {
                        this.db.createObjectStore('appState', { keyPath: 'key' });
                     }
                  };
               });
            }
            /**
             * Save a chat object to IndexedDB and update in-memory cache
             * @param {Object} chat - Chat object to save
             */
            async saveChat(chat) {
               if (!this.db) return;

               try {
                  const transaction = this.db.transaction(['chats'], 'readwrite');
                  const store = transaction.objectStore('chats');
                  await this.promisifyRequest(store.put(chat));
                  this.state.chats[chat.id] = chat;
                  this.showSaving();
               } catch (error) {
                  console.error('Error saving chat:', error);
                  if (error.name === 'QuotaExceededError') {
                     await this.showNotification('error', 'Storage Full', 'Please delete some chats to free up space');
                  } else if (error.name === 'InvalidStateError') {
                     // Handle database corruption
                     await this.showNotification('error', 'Database Error', 'Database corrupted. Please refresh the page.');
                  }
               }
            }
            /**
             * Load all chats from IndexedDB into memory cache
             */
            async loadChats() {
               if (!this.db) return;

               try {
                  const transaction = this.db.transaction(['chats'], 'readonly');
                  const store = transaction.objectStore('chats');
                  const chats = await this.promisifyRequest(store.getAll());

                  // Populate in-memory cache
                  this.state.chats = {};
                  chats.forEach((chat) => {
                     this.state.chats[chat.id] = chat;
                  });
               } catch (error) {
                  console.error('Error loading chats:', error);
                  if (error.name === 'InvalidStateError') {
                     // Handle database corruption
                     await this.showNotification('error', 'Database Error', 'Database corrupted. Please refresh the page.');
                  }
               }
            }
            /**
             * Delete a chat from IndexedDB and memory cache
             * @param {string} chatId - ID of chat to delete
             */
            async deleteChat(chatId) {
               if (!this.db) return;

               try {
                  const transaction = this.db.transaction(['chats'], 'readwrite');
                  const store = transaction.objectStore('chats');
                  await this.promisifyRequest(store.delete(chatId));
                  delete this.state.chats[chatId];
               } catch (error) {
                  console.error('Error deleting chat:', error);
               }
            }
            /**
             * Save application settings to IndexedDB
             * @param {Object} settings - Settings object to save
             */
            async saveSettings(settings) {
               if (!this.db) return;

               try {
                  const transaction = this.db.transaction(['settings'], 'readwrite');
                  const store = transaction.objectStore('settings');
                  await this.promisifyRequest(store.put({ key: 'main', ...settings }));
                  this.state.settings = settings;
               } catch (error) {
                  console.error('Error saving settings:', error);
               }
            }

            /**
             * Save theme preference to IndexedDB
             * @param {string} theme - Theme value ('light' or 'dark')
             */
            async saveTheme(theme) {
               if (!this.db) return;

               try {
                  const transaction = this.db.transaction(['settings'], 'readwrite');
                  const store = transaction.objectStore('settings');
                  await this.promisifyRequest(store.put({ key: 'theme', value: theme }));
                  this.state.theme = theme;
               } catch (error) {
                  console.error('Error saving theme:', error);
               }
            }

            /**
             * Load theme preference from IndexedDB
             * @returns {Promise<string>} Resolves with theme value ('light' or 'dark')
             */
            async loadTheme() {
               if (!this.db) return 'light';

               try {
                  const transaction = this.db.transaction(['settings'], 'readonly');
                  const store = transaction.objectStore('settings');
                  const result = await this.promisifyRequest(store.get('theme'));
                  return result ? result.value : 'light';
               } catch (error) {
                  console.error('Error loading theme:', error);
                  return 'light';
               }
            }

            /**
             * Apply theme to UI and update theme toggle button
             * @param {string} theme - Theme to apply ('light' or 'dark')
             */
            setTheme(theme) {
               document.documentElement.setAttribute('data-theme', theme);
               this.state.theme = theme;
               const themeIcon = document.getElementById('themeIcon');
               const themeText = document.querySelector('#themeToggle span:last-child');
               if (theme === 'dark') {
                  themeIcon.textContent = '☀';
                  themeText.textContent = 'Light Mode';
               } else {
                  themeIcon.textContent = '🌙';
                  themeText.textContent = 'Dark Mode';
               }
            }

            /**
             * Toggle between light and dark themes
             */
            toggleTheme() {
               const newTheme = this.state.theme === 'light' ? 'dark' : 'light';
               this.setTheme(newTheme);
               this.saveTheme(newTheme);
            }
            
            /**
             * Load application settings from IndexedDB
             */
            async loadSettings() {
               if (!this.db) return;

               try {
                  const transaction = this.db.transaction(['settings'], 'readonly');
                  const store = transaction.objectStore('settings');
                  const result = await this.promisifyRequest(store.get('main'));

                  if (result) {
                     const { key, ...settings } = result;
                     this.state.settings = { ...this.state.settings, ...settings };
                  }
               } catch (error) {
                  console.error('Error loading settings:', error);
               }

               const savedTheme = await this.loadTheme();
               this.setTheme(savedTheme);
            }
            /**
             * Save application state values to IndexedDB
             * @param {string} key - State key to save
             * @param {*} value - State value to save
             */
            async saveAppState(key, value) {
               if (!this.db) return;

               try {
                  const transaction = this.db.transaction(['appState'], 'readwrite');
                  const store = transaction.objectStore('appState');
                  await this.promisifyRequest(store.put({ key, value }));
               } catch (error) {
                  console.error('Error saving app state:', error);
               }
            }
            
            /**
             * Load application state values from IndexedDB
             * @param {string} key - State key to load
             * @returns {Promise<*>} Resolves with state value or null
             */
            async loadAppState(key) {
               if (!this.db) return null;

               try {
                  const transaction = this.db.transaction(['appState'], 'readonly');
                  const store = transaction.objectStore('appState');
                  const result = await this.promisifyRequest(store.get(key));
                  return result ? result.value : null;
               } catch (error) {
                  console.error('Error loading app state:', error);
                  return null;
               }
            }
            /**
             * Convert IndexedDB request to Promise for easier async/await usage
             * @param {IDBRequest} request - IndexedDB request object
             * @returns {Promise} Resolves with request result or rejects with error
             */
            promisifyRequest(request) {
               return new Promise((resolve, reject) => {
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = () => reject(request.error);
               });
            }
            
            /**
             * Show loading overlay with optional message
             * @param {string} message - Loading message to display
             */
            showLoading(message = 'Loading...') {
               const overlay = document.getElementById('loadingOverlay');
               const text = document.getElementById('loadingText');
               text.textContent = message;
               overlay.style.display = 'flex';
            }
            
            /**
             * Hide loading overlay
             */
            hideLoading() {
               document.getElementById('loadingOverlay').style.display = 'none';
            }

            /**
             * Add event listener with tracking for cleanup
             * @param {Element} element - DOM element to attach listener to
             * @param {string} event - Event type
             * @param {Function} handler - Event handler function
             */
            addTrackedEventListener(element, event, handler) {
               element.addEventListener(event, handler);
               const key = `${element.tagName}-${element.id || element.className}-${event}`;
               this.eventListeners.set(key, { element, event, handler });
            }

            /**
             * Remove all tracked event listeners
             */
            removeAllEventListeners() {
               this.eventListeners.forEach(({ element, event, handler }) => {
                  element.removeEventListener(event, handler);
               });
               this.eventListeners.clear();
            }

            /**
             * Show modal by ID
             * @param {string} modalId - ID of modal element to show
             */
            showModal(modalId) {
               document.getElementById(modalId).classList.add('show');
            }

            /**
             * Hide modal by ID
             * @param {string} modalId - ID of modal element to hide
             */
            hideModal(modalId) {
               document.getElementById(modalId).classList.remove('show');
            }

            /**
             * Briefly show saving status in connection indicator
             */
            showSaving() {
               const statusIndicator = document.getElementById('statusIndicator');
               const statusText = document.getElementById('statusText');
               const originalClass = statusIndicator.className;
               const originalText = statusText.textContent;

               statusIndicator.className = 'status-indicator saving';
               statusText.textContent = 'Saving...';

               setTimeout(() => {
                  statusIndicator.className = originalClass;
                  statusText.textContent = originalText;
               }, 1000);
            }
            
            /**
             * Update connection status indicator based on current state
             */
            updateConnectionStatus() {
               const statusIndicator = document.getElementById('statusIndicator');
               const statusText = document.getElementById('statusText');

               if (this.state.isConnected) {
                  statusIndicator.className = 'status-indicator connected';
                  statusText.textContent = `Connected (${this.state.models.length} models)`;
               } else {
                  statusIndicator.className = 'status-indicator disconnected';
                  if (this.state.connectionError) {
                     switch (this.state.connectionError) {
                        case 'CORS_ERROR':
                           statusText.textContent = 'CORS Error - Check setup';
                           statusText.title = 'Click Settings for troubleshooting';
                           break;
                        case 'NETWORK_ERROR':
                           statusText.textContent = 'Network Error';
                           break;
                        case 'NOT_FOUND':
                           statusText.textContent = 'Ollama not found';
                           break;
                        case 'SERVER_ERROR':
                           statusText.textContent = 'Server Error';
                           break;
                        default:
                           statusText.textContent = 'Connection Failed';
                     }
                  } else {
                     statusText.textContent = 'Disconnected';
                  }
               }
            }
            /**
             * Load available models from Ollama API
             * Updates connection status and UI components on success/failure
             */
            async loadModels() {
               try {
                  console.log(`Attempting to connect to Ollama at: ${this.state.settings.ollamaUrl}`);
                  const response = await this.fetchWithTimeout(`${this.state.settings.ollamaUrl}/api/tags`, {
                     method: 'GET',
                     headers: { 'Content-Type': 'application/json' }
                  });

                  if (response.ok) {
                     const data = await response.json();
                     // Sort models alphabetically by name
                     this.state.models = (data.models || []).sort((a, b) => a.name.localeCompare(b.name));
                     this.state.isConnected = true;
                     this.state.connectionError = null;
                     this.updateModelSelect();
                     this.updateConnectionStatus();
                     this.updateModelList();
                     console.log(`Successfully loaded ${this.state.models.length} models`);
                  } else {
                     throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
               } catch (error) {
                  console.error('Error loading models:', error);
                  this.state.isConnected = false;
                  this.state.connectionError = this.getConnectionErrorMessage(error);
                  this.updateConnectionStatus();
               }
            }
            /**
             * Classify connection errors for better user feedback
             * @param {Error} error - Error object from fetch request
             * @returns {string} Error type identifier
             */
            getConnectionErrorMessage(error) {
               if (error.name === 'TypeError' && error.message.includes('fetch')) {
                  return 'CORS_ERROR';
               } else if (error.message.includes('NetworkError')) {
                  return 'NETWORK_ERROR';
               } else if (error.message.includes('404')) {
                  return 'NOT_FOUND';
               } else if (error.message.includes('500')) {
                  return 'SERVER_ERROR';
               } else {
                  return 'UNKNOWN_ERROR';
               }
            }
            
            /**
             * Populate model selection dropdown with available models
             */
            updateModelSelect() {
               const modelSelect = document.getElementById('modelSelect');
               modelSelect.innerHTML = '<option value="">Select Model...</option>';

               this.state.models.forEach((model) => {
                  const option = document.createElement('option');
                  option.value = model.name;
                  option.textContent = model.name;
                  if (model.name === this.state.selectedModel) {
                     option.selected = true;
                  }
                  modelSelect.appendChild(option);
               });
            }
            /**
             * Update model management list in settings modal
             */
            updateModelList() {
               const modelList = document.getElementById('modelList');
               modelList.innerHTML = '';

               this.state.models.forEach((model) => {
                  const modelItem = document.createElement('div');
                  modelItem.className = 'model-item';
                  const sizeText = model.size ? this.formatBytes(model.size) : 'Size unknown';
                  modelItem.innerHTML = `
                     <div class="model-info">
                        <div class="model-name">${this.escapeHtml(model.name)}</div>
                        <div class="model-size">${sizeText} • Modified: ${new Date(model.modified_at).toLocaleDateString()}</div>
                     </div>
                     <div class="model-actions">
                        <button class="model-btn danger" onclick="app.deleteModel('${model.name}')">Remove</button>
                     </div>
                  `;
                  modelList.appendChild(modelItem);
               });

               if (this.state.models.length === 0) {
                  modelList.innerHTML = '<div style="text-align:center;color:var(--text-secondary);padding:20px">No models installed. Use the input above to pull a model.</div>';
               }
            }
            /**
             * Pull a model from Ollama registry with streaming progress updates
             * @param {string} modelName - Name of model to pull
             */
            async pullModel(modelName) {
               if (!modelName.trim()) {
                  await this.showNotification('warning', 'Invalid Input', 'Please enter a model name');
                  return;
               }

               const addBtn = document.getElementById('addModelBtn');
               const addInput = document.getElementById('addModelInput');
               const terminal = document.getElementById('terminal');
               const terminalOutput = document.getElementById('terminalOutput');

               // Disable UI during operation
               addBtn.disabled = true;
               addBtn.textContent = 'Pulling...';
               addInput.disabled = true;
               terminal.classList.add('visible');
               terminalOutput.innerHTML = '';

               this.addTerminalLine('Starting model pull process...', 'info');
               this.addTerminalLine(`Pulling model: ${modelName}`, 'info');

               try {
                  const response = await this.fetchWithTimeout(`${this.state.settings.ollamaUrl}/api/pull`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ name: modelName, stream: true })
                  });

                  if (!response.ok) {
                     throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }

                  const reader = response.body.getReader();
                  const decoder = new TextDecoder();
                  let buffer = '';

                  // Stream the response lines and parse JSON for progress updates
                  while (true) {
                     const { done, value } = await reader.read();
                     if (done) break;

                     buffer += decoder.decode(value, { stream: true });
                     const lines = buffer.split('\n');
                     buffer = lines.pop() || '';

                     for (const line of lines) {
                        if (line.trim()) {
                           try {
                              const data = JSON.parse(line);
                              if (data.status) {
                                 let statusText = data.status;
                                 // Add percentage if available
                                 if (data.completed && data.total) {
                                    const percent = Math.round((data.completed / data.total) * 100);
                                    statusText += ` (${percent}%)`;
                                 }
                                 this.addTerminalLine(statusText, 'info');
                              }
                              if (data.error) {
                                 this.addTerminalLine(`Error: ${data.error}`, 'error');
                              }
                           } catch (parseError) {
                              console.warn('Failed to parse pull response:', line);
                           }
                        }
                     }
                  }

                  this.addTerminalLine(`Successfully pulled model: ${modelName}`, 'success');
                  addInput.value = '';
                  await this.loadModels();
                  await this.showNotification('success', 'Model Downloaded', `Successfully pulled model: ${modelName}`);
               } catch (error) {
                  console.error('Error pulling model:', error);
                  this.addTerminalLine(`Failed to pull model: ${error.message}`, 'error');
                  await this.showNotification('error', 'Download Failed', `Failed to pull model: ${error.message}`);
               }

               // Re-enable UI
               addBtn.disabled = false;
               addBtn.textContent = 'Pull Model';
               addInput.disabled = false;
            }
            /**
             * Delete a model from Ollama with confirmation dialog
             * @param {string} modelName - Name of model to delete
             */
            async deleteModel(modelName) {
               const confirmed = await this.showConfirmation(
                  'Remove Model',
                  `Are you sure you want to remove the model "${modelName}"? This action cannot be undone.`
               );
               if (!confirmed) return;

               const terminal = document.getElementById('terminal');
               const terminalOutput = document.getElementById('terminalOutput');

               terminal.classList.add('visible');
               terminalOutput.innerHTML = '';

               this.addTerminalLine('Starting model deletion process...', 'info');
               this.addTerminalLine(`Removing model: ${modelName}`, 'info');

               try {
                  const response = await this.fetchWithTimeout(`${this.state.settings.ollamaUrl}/api/delete`, {
                     method: 'DELETE',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ name: modelName })
                  });

                  if (response.ok) {
                     this.addTerminalLine(`Successfully removed model: ${modelName}`, 'success');
                     // Clear selection if deleted model was selected
                     if (this.state.selectedModel === modelName) {
                        this.state.selectedModel = '';
                        await this.saveAppState('selectedModel', '');
                     }
                     await this.loadModels();
                     await this.showNotification('success', 'Model Removed', `Successfully removed model: ${modelName}`);
                  } else {
                     throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }
               } catch (error) {
                  console.error('Error deleting model:', error);
                  this.addTerminalLine(`Failed to remove model: ${error.message}`, 'error');
                  await this.showNotification('error', 'Removal Failed', `Failed to remove model: ${error.message}`);
               }
            }
            /**
             * Add a line to the terminal output with timestamp and type styling
             * Implements line updating for progress messages to reduce clutter
             * @param {string} text - Text to add to terminal
             * @param {string} type - Line type ('info', 'success', 'error', 'warning')
             */
            addTerminalLine(text, type = 'info') {
               const terminalOutput = document.getElementById('terminalOutput');
               const timestamp = new Date().toLocaleTimeString();
               const fullText = `[${timestamp}] ${text}`;

               const lines = terminalOutput.querySelectorAll('.terminal-line');
               const lastLine = lines[lines.length - 1];

               // Check if we should update the last line instead of adding new one
               if (lastLine && this.shouldUpdateLastLine(lastLine.textContent, fullText)) {
                  lastLine.className = `terminal-line ${type}`;
                  lastLine.textContent = fullText;
               } else {
                  const line = document.createElement('div');
                  line.className = `terminal-line ${type}`;
                  line.textContent = fullText;
                  terminalOutput.appendChild(line);
               }

               // Limit to last 50 lines to prevent memory bloat
               const allLines = Array.from(terminalOutput.querySelectorAll('.terminal-line'));
               if (allLines.length > 50) {
                  allLines.slice(0, allLines.length - 50).forEach(line => line.remove());
               }

               terminalOutput.scrollTop = terminalOutput.scrollHeight;
            }
            /**
             * Determine if a new terminal line should update the previous line
             * Used for progress updates to avoid spamming the terminal
             * @param {string} lastLineText - Text of the last terminal line
             * @param {string} newLineText - Text of the new line to add
             * @returns {boolean} True if the last line should be updated instead of adding new
             */
            shouldUpdateLastLine(lastLineText, newLineText) {
               // Extract the message part after timestamp
               const extractMessage = (line) => {
                  const match = line.match(/\[\d+:\d+:\d+\s*[AP]M\]\s*(.+)/);
                  return match ? match[1] : line;
               };

               const lastMessage = extractMessage(lastLineText);
               const newMessage = extractMessage(newLineText);

               if (lastMessage && newMessage) {
                  // Normalize by removing percentage suffixes for comparison
                  const normalizeMessage = (msg) => msg.replace(/\s*\(\d+%\).*$/, '').trim();
                  const lastNormalized = normalizeMessage(lastMessage);
                  const newNormalized = normalizeMessage(newMessage);

                  // Update if messages are the same (ignoring percentages)
                  if (lastNormalized === newNormalized && lastNormalized.length > 0) {
                     return true;
                  }

                  // Check for common progress patterns to allow updates
                  const progressPatterns = [
                     /^pulling\s+[a-f0-9]+/,
                     /^verifying\s+sha256/,
                     /^writing\s+manifest/,
                     /^removing\s+/
                  ];

                  for (const pattern of progressPatterns) {
                     if (pattern.test(lastNormalized) && pattern.test(newNormalized)) {
                        return true;
                     }
                  }
               }

               return false;
            }
            /**
             * Format byte values into human-readable strings
             * @param {number} bytes - Number of bytes to format
             * @param {number} decimals - Number of decimal places (default: 2)
             * @returns {string} Formatted byte string (e.g., "1.25 MB")
             */
            formatBytes(bytes, decimals = 2) {
               if (bytes === 0) return '0 Bytes';

               const k = 1024;
               const dm = decimals < 0 ? 0 : decimals;
               const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
               const i = Math.floor(Math.log(bytes) / Math.log(k));

               return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            /**
             * Create a new chat session with initial state
             */
            async createNewChat() {
               const chatId = 'chat_' + Date.now();
               const chat = {
                  id: chatId,
                  title: 'New Chat',
                  messages: [],
                  model: this.state.selectedModel,
                  createdAt: new Date()
               };

               await this.saveChat(chat);
               this.state.currentChatId = chatId;
               await this.saveAppState('currentChatId', chatId);
               this.updateUI();
            }
            /**
             * Select and activate a chat session
             * @param {string} chatId - ID of chat to select
             */
            async selectChat(chatId) {
               this.state.currentChatId = chatId;
               await this.saveAppState('currentChatId', chatId);
               this.updateUI();
            }
            /**
             * Handle chat deletion with confirmation dialog
             * @param {string} chatId - ID of chat to delete
             */
            async deleteChatHandler(chatId) {
               const confirmed = await this.showConfirmation(
                  'Delete Chat',
                  'Are you sure you want to delete this chat? This action cannot be undone.'
               );

               if (confirmed) {
                  await this.deleteChat(chatId);
                  // Clear current chat if deleted chat was active
                  if (this.state.currentChatId === chatId) {
                     this.state.currentChatId = null;
                     await this.saveAppState('currentChatId', null);
                  }
                  this.updateUI();
               }
            }
            /**
             * Clear all messages from the current chat with confirmation
             */
            async clearChat() {
               if (this.state.currentChatId) {
                  const confirmed = await this.showConfirmation(
                     'Clear Chat',
                     'Are you sure you want to clear all messages in this chat?'
                  );

                  if (confirmed) {
                     const currentChat = this.state.chats[this.state.currentChatId];
                     currentChat.messages = [];
                     await this.saveChat(currentChat);
                     this.updateUI();
                  }
               }
            }
            /**
             * Copy text to clipboard with fallback for older browsers
             * @param {string} text - Text to copy to clipboard
             * @returns {Promise<boolean>} Resolves with true if successful
             */
            async copyToClipboard(text) {
               try {
                  await navigator.clipboard.writeText(text);
                  return true;
               } catch (err) {
                  // Fallback for older browsers
                  const textArea = document.createElement("textarea");
                  textArea.value = text;
                  textArea.style.position = "fixed";
                  textArea.style.left = "-999999px";
                  document.body.appendChild(textArea);
                  textArea.focus();
                  textArea.select();

                  try {
                     document.execCommand('copy');
                     document.body.removeChild(textArea);
                     return true;
                  } catch (err) {
                     document.body.removeChild(textArea);
                     return false;
                  }
               }
            }
            /**
             * Strip HTML formatting from content for plain text clipboard copy
             * @param {string} content - HTML formatted content
             * @returns {string} Plain text content
             */
            stripFormatting(content) {
               return content
                  .replace(/<[^>]*>/g, '')
                  .replace(/&lt;/g, '<')
                  .replace(/&gt;/g, '>')
                  .replace(/&amp;/g, '&')
                  .replace(/&quot;/g, '"')
                  .replace(/&#39;/g, "'");
            }
            /**
             * Stop the current streaming response
             */
            async stopStreaming() {
               if (this.currentStream) {
                  this.currentStream.abort();
                  this.currentStream = null;
                  this.state.isStreaming = false;
                  this.updateSendButton();
               }
            }
            /**
             * Sends a user message to the selected model via Ollama API with streaming.
             * Handles chat creation, prompt building, streaming parsing, and errors.
             */
            async sendMessage() {
               const messageInput = document.getElementById('messageInput');
               const message = messageInput.value.trim();

               // Validate input and model selection
               if (!message || !this.state.selectedModel) {
                  if (!this.state.selectedModel) {
                     await this.showNotification('warning', 'No Model Selected', 'Please select a model first');
                  }
                  return;
               }

               // Create new chat if none exists
               if (!this.state.currentChatId) {
                  await this.createNewChat();
               }

               const currentChat = this.state.chats[this.state.currentChatId];
               const userMessage = {
                  id: 'msg_' + Date.now(),
                  role: 'user',
                  content: message,
                  timestamp: new Date()
               };
               currentChat.messages.push(userMessage);

               // Set chat title to first message if it's the first message
               if (currentChat.messages.length === 1) {
                  currentChat.title = message.length > 30 ? message.substring(0, 30) + '...' : message;
               }

               await this.saveChat(currentChat);
               messageInput.value = '';
               this.autoResize(messageInput);
               this.updateUI();

               // Prepare for streaming response
               this.state.isStreaming = true;
               this.updateSendButton();

               const assistantMessage = {
                  id: 'msg_' + Date.now(),
                  role: 'assistant',
                  content: '',
                  timestamp: new Date(),
                  isStreaming: true
               };
               currentChat.messages.push(assistantMessage);
               this.updateUI();

               try {
                  this.currentStream = new AbortController();
                  const response = await this.fetchWithTimeout(`${this.state.settings.ollamaUrl}/api/generate`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({
                        model: this.state.selectedModel,
                        prompt: this.buildPrompt(currentChat.messages.slice(0, -1)),
                        stream: true,
                        options: {
                           temperature: this.state.settings.temperature,
                           top_p: this.state.settings.topP
                        }
                     }),
                     signal: this.currentStream.signal
                  });

                  if (!response.ok) {
                     throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }

                  const reader = response.body.getReader();
                  const decoder = new TextDecoder();
                  let buffer = '';

                  // Stream and parse response lines for real-time updates
                  while (true) {
                     const { done, value } = await reader.read();
                     if (done) break;

                     const chunk = decoder.decode(value, { stream: true });
                     buffer += chunk;
                     const lines = buffer.split('\n');
                     buffer = lines.pop() || '';

                     for (const line of lines) {
                        const trimmedLine = line.trim();
                        if (trimmedLine) {
                           try {
                              const data = JSON.parse(trimmedLine);
                              if (data.response) {
                                 assistantMessage.content += data.response;
                                 this.updateStreamingMessage(assistantMessage);
                              }
                              if (data.done) {
                                 assistantMessage.isStreaming = false;
                                 this.state.isStreaming = false;
                                 this.updateSendButton();
                                 await this.saveChat(currentChat);
                                 this.updateUI();
                                 return;
                              }
                           } catch (parseError) {
                              console.warn('Failed to parse streaming response line:', trimmedLine);
                           }
                        }
                     }
                  }

                  // Handle any remaining buffer content
                  if (buffer.trim()) {
                     try {
                        const data = JSON.parse(buffer.trim());
                        if (data.response) {
                           assistantMessage.content += data.response;
                           this.updateStreamingMessage(assistantMessage);
                        }
                     } catch (parseError) {
                        console.warn('Failed to parse final buffer:', buffer);
                     }
                  }

                  // Finalize streaming state
                  assistantMessage.isStreaming = false;
                  this.state.isStreaming = false;
                  this.updateSendButton();
                  await this.saveChat(currentChat);
                  this.updateUI();
               } catch (error) {
                  if (error.name === 'AbortError') {
                     // User stopped the stream
                     assistantMessage.content += ' [Response stopped by user]';
                     assistantMessage.isStreaming = false;
                     await this.saveChat(currentChat);
                     this.updateUI();
                  } else {
                     // Handle other errors
                     console.error('Error sending message:', error);
                     currentChat.messages.pop();
                     const errorMessage = {
                        id: 'msg_' + Date.now(),
                        role: 'assistant',
                        content: 'Sorry, I encountered an error while processing your request. Please check your connection to Ollama.',
                        timestamp: new Date()
                     };
                     currentChat.messages.push(errorMessage);
                     await this.saveChat(currentChat);
                     this.updateUI();
                     await this.showNotification('error', 'Message Error', 'Failed to send message. Please check your connection to Ollama.');
                  }
                  this.state.isStreaming = false;
                  this.updateSendButton();
               }
            }
            /**
             * Updates the UI for a streaming assistant message with throttling.
             * Formats content and adds cursor if streaming.
             * @param {Object} message - The assistant message object.
             */
            updateStreamingMessage(message) {
               // Throttle updates to prevent UI lag during rapid streaming
               const now = Date.now();
               // Limit to ~60fps (16ms per frame)
               if (this.streamingUpdateThrottle || (now - this.lastStreamingUpdate < 16)) {
                  return;
               }
               
               this.streamingUpdateThrottle = true;
               this.lastStreamingUpdate = now;
               
               requestAnimationFrame(() => {
                  const messageElements = document.querySelectorAll('.message.assistant');
                  const lastMessageEl = messageElements[messageElements.length - 1];

                  if (lastMessageEl) {
                     const contentEl = lastMessageEl.querySelector('.message-text');
                     if (contentEl) {
                        let formattedContent = this.formatMessage(message.content);
                        if (message.isStreaming) {
                           formattedContent += '<span class="streaming-cursor">|</span>';
                        }
                        contentEl.innerHTML = formattedContent;
                        this.scrollToBottom();
                     }
                  }
                  this.streamingUpdateThrottle = false;
               });
            }
            /**
             * Builds a prompt string from chat messages for Ollama API.
             * Filters streaming messages and formats as Human/Assistant dialogue.
             * @param {Array} messages - Array of message objects.
             * @returns {string} The formatted prompt.
             */
            buildPrompt(messages) {
               // Filter out any messages still streaming
               const validMessages = messages.filter((msg) => !msg.isStreaming);
               return validMessages
                  .map((msg) => {
                     const role = msg.role === 'user' ? 'Human' : 'Assistant';
                     return `${role}: ${msg.content}`;
                  })
                  .join('\n\n') + '\n\nAssistant:';
            }
            /**
             * Updates all UI components: chat list, messages, title, and send button.
             */
            updateUI() {
               this.updateChatList();
               this.updateMessages();
               this.updateChatTitle();
               this.updateSendButton();
            }
            /**
             * Renders the chat list in the sidebar, sorted by creation date descending.
             * Uses event delegation for better performance.
             */
            updateChatList() {
               const chatList = document.getElementById('chatList');
               chatList.innerHTML = '';

               Object.values(this.state.chats)
                  .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
                  .forEach((chat) => {
                     const chatItem = document.createElement('div');
                     chatItem.className = `chat-item ${chat.id === this.state.currentChatId ? 'active' : ''}`;
                     chatItem.dataset.chatId = chat.id;

                     const lastMessage = chat.messages.length > 0 ? chat.messages[chat.messages.length - 1] : null;
                     const preview = lastMessage
                        ? (lastMessage.content.length > 50
                              ? lastMessage.content.substring(0, 50) + '...'
                              : lastMessage.content)
                        : 'No messages yet';

                     chatItem.innerHTML = `
                        <div class="chat-content">
                           <div class="chat-title">${this.escapeHtml(chat.title)}</div>
                           <div class="chat-preview">${this.escapeHtml(preview)}</div>
                        </div>
                        <button class="chat-delete" title="Delete chat">×</button>
                     `;

                     chatList.appendChild(chatItem);
                  });
            }
            /**
             * Renders messages in the current chat or welcome message if no chat selected.
             * Adds copy buttons and streaming cursor.
             */
            updateMessages() {
               const container = document.getElementById('messagesContainer');

               if (!this.state.currentChatId) {
                  container.innerHTML = `
                     <div class="message assistant">
                        <div class="message-avatar">AI</div>
                        <div class="message-content">
                           <div class="message-text">Hello! I'm your AI assistant. Please select a model from the sidebar to start chatting.</div>
                           <div class="message-time">Just now</div>
                        </div>
                     </div>
                  `;
                  return;
               }

               const currentChat = this.state.chats[this.state.currentChatId];
               container.innerHTML = '';

               currentChat.messages.forEach((message) => {
                  const messageEl = document.createElement('div');
                  messageEl.className = `message ${message.role}`;

                  const avatar = message.role === 'user' ? 'You' : 'AI';
                  const formattedContent = this.formatMessage(message.content);
                  const timeStr = this.formatTime(message.timestamp);

                  let messageContent = formattedContent;
                  if (message.isStreaming) {
                     messageContent += '<span class="streaming-cursor">|</span>';
                  }

                  messageEl.innerHTML = `
                     <div class="message-avatar">${avatar}</div>
                     <div class="message-content">
                        <button class="copy-btn" title="Copy message">📋</button>
                        <div class="message-text">${messageContent}</div>
                        <div class="message-time">${timeStr}</div>
                     </div>
                  `;

                  const copyBtn = messageEl.querySelector('.copy-btn');
                  copyBtn.addEventListener('click', async () => {
                     const plainText = this.stripFormatting(message.content);
                     const success = await this.copyToClipboard(plainText);
                     if (success) {
                        copyBtn.textContent = '✓';
                        setTimeout(() => {
                           copyBtn.textContent = '📋';
                        }, 2000);
                     }
                  });

                  container.appendChild(messageEl);
               });

               this.scrollToBottom();
            }
            /**
             * Updates the chat title in the header based on current chat.
             */
            updateChatTitle() {
               const titleEl = document.getElementById('chatTitle');

               if (this.state.currentChatId) {
                  const currentChat = this.state.chats[this.state.currentChatId];
                  titleEl.textContent = currentChat.title;
               } else {
                  titleEl.textContent = 'Welcome to Ollama WebUI Chat';
               }
            }
            /**
             * Updates the send/stop button state based on streaming and connection.
             */
            updateSendButton() {
               const sendBtn = document.getElementById('sendBtn');

               if (this.state.isStreaming) {
                  sendBtn.className = 'stop-btn';
                  sendBtn.innerHTML = '■';
                  sendBtn.disabled = false;
               } else {
                  sendBtn.className = 'send-btn';
                  sendBtn.innerHTML = '➤';
                  sendBtn.disabled = !this.state.selectedModel || !this.state.isConnected;
               }
            }
            /**
             * Escapes HTML characters in text to prevent XSS.
             * @param {string} text - The text to escape.
             * @returns {string} Escaped HTML.
             */
            escapeHtml(text) {
               const map = {
                  '&': '&amp;',
                  '<': '&lt;',
                  '>': '&gt;',
                  '"': '&quot;',
                  "'": '&#39;'
               };
               return text.replace(/[&<>"']/g, char => map[char]);
            }
            /**
             * Formats message content with basic Markdown support (code blocks, bold, italic, line breaks).
             * @param {string} content - The raw message content.
             * @returns {string} HTML-formatted content.
             */
            formatMessage(content) {
               if (!content) return '';

               // Escape HTML to prevent XSS
               content = this.escapeHtml(content);
               
               // Format code blocks
               content = content.replace(/```([\s\S]*?)```/g, '<div class="code-block">$1</div>');
               
               // Format inline code
               content = content.replace(/`([^`]+)`/g, '<span class="inline-code">$1</span>');
               
               // Format bold text
               content = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
               
               // Format italic text
               content = content.replace(/\*(.*?)\*/g, '<em>$1</em>');
               
               // Convert line breaks
               content = content.replace(/\n/g, '<br>');

               return content;
            }
            /**
             * Formats a timestamp relative to now (e.g., 'Just now', '2h ago') or date string.
             * @param {Date} timestamp - The message timestamp.
             * @returns {string} Formatted time string.
             */
            formatTime(timestamp) {
               const now = new Date();
               const diff = now - new Date(timestamp);

               if (diff < 60000) {
                  return 'Just now';
               } else if (diff < 3600000) {
                  return Math.floor(diff / 60000) + 'm ago';
               } else if (diff < 86400000) {
                  return Math.floor(diff / 3600000) + 'h ago';
               } else {
                  return new Date(timestamp).toLocaleDateString();
               }
            }
            /**
             * Auto-resizes a textarea to fit content, max 120px height.
             * @param {HTMLTextAreaElement} textarea - The textarea element.
             */
            autoResize(textarea) {
               textarea.style.height = 'auto';
               textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            }
            /**
             * Scrolls the messages container to the bottom.
             */
            scrollToBottom() {
               const container = document.getElementById('messagesContainer');
               container.scrollTop = container.scrollHeight;
            }

            /**
             * Fetch with timeout support
             * @param {string} url - URL to fetch
             * @param {Object} options - Fetch options
             * @param {number} timeout - Timeout in milliseconds (default: 30000)
             * @returns {Promise<Response>} Fetch response
             */
            async fetchWithTimeout(url, options = {}, timeout = 30000) {
               const controller = new AbortController();
               const timeoutId = setTimeout(() => controller.abort(), timeout);
               
               try {
                  const response = await fetch(url, {
                     ...options,
                     signal: controller.signal
                  });
                  clearTimeout(timeoutId);
                  return response;
               } catch (error) {
                  clearTimeout(timeoutId);
                  throw error;
               }
            }
            /**
             * Shows the settings modal, populates fields, and updates diagnostics/model list.
             */
            showSettings() {
               const modal = document.getElementById('settingsModal');

               document.getElementById('ollamaUrl').value = this.state.settings.ollamaUrl;
               document.getElementById('temperature').value = this.state.settings.temperature;
               document.getElementById('topP').value = this.state.settings.topP;

               this.updateConnectionDiagnostics();
               this.updateModelList();
               this.showModal('settingsModal');
            }
            /**
             * Hides the settings modal and terminal.
             */
            hideSettings() {
               this.hideModal('settingsModal');
               document.getElementById('terminal').classList.remove('visible');
            }
            /**
             * Updates the connection diagnostics list in settings modal.
             */
            updateConnectionDiagnostics() {
               const diagnosticsEl = document.getElementById('connectionDiagnostics');
               let diagnostics = [];

               // Check overall connection status
               if (this.state.isConnected) {
                  diagnostics.push({
                     status: 'success',
                     message: `✔ Connected to Ollama (${this.state.models.length} models available)`
                  });
               } else {
                  diagnostics.push({
                     status: 'error',
                     message: '✗ Cannot connect to Ollama server'
                  });
                  if (this.state.connectionError === 'CORS_ERROR') {
                     diagnostics.push({
                        status: 'warning',
                        message: '⚠ CORS not enabled - Start Ollama with: export OLLAMA_ORIGINS=* &amp;&amp; ollama serve'
                     });
                  }
               }

               // Validate URL format
               const url = this.state.settings.ollamaUrl;
               if (!url.startsWith('http://') && !url.startsWith('https://')) {
                  diagnostics.push({
                     status: 'error',
                     message: '✗ Invalid URL format - Must start with http:// or https://'
                  });
               } else {
                  diagnostics.push({
                     status: 'success',
                     message: '✔ URL format is valid'
                  });
               }

               // Check for default port
               if (url.includes(':11434')) {
                  diagnostics.push({
                     status: 'success',
                     message: '✔ Using default Ollama port (11434)'
                  });
               }

               // Render diagnostics as HTML
               diagnosticsEl.innerHTML = diagnostics
                  .map(
                     (item) => `
                        <div class="diagnostic-item">
                           <div class="diagnostic-status ${item.status}"></div>
                           <span>${item.message}</span>
                        </div>
                     `
                  )
                  .join('');
            }

            /**
             * Tests connection to Ollama at the specified URL and shows results.
             */
            async testConnection() {
               const testBtn = document.getElementById('testConnectionBtn');
               const originalText = testBtn.textContent;
               testBtn.textContent = 'Testing...';
               testBtn.disabled = true;

               try {
                  const testUrl = document.getElementById('ollamaUrl').value;
                  const response = await this.fetchWithTimeout(`${testUrl}/api/tags`, {
                     method: 'GET',
                     headers: { 'Content-Type': 'application/json' }
                  });

                  if (response.ok) {
                     const data = await response.json();
                     const modelList = data.models?.map(m => m.name).join('\n') || 'No models available';
                     await this.showNotification('success', 'Connection Successful', `Found ${data.models?.length || 0} models:\n\n${modelList}`);
                  } else {
                     await this.showNotification('error', 'Connection Failed', `HTTP ${response.status}: ${response.statusText}`);
                  }
               } catch (error) {
                  let errorMessage = '';
                  if (error.name === 'TypeError' && error.message.includes('fetch')) {
                     errorMessage = 'CORS Error: Ollama server is not configured to allow web browser connections.\n\nSolution (Linux):\n1. Stop Ollama\n2. Start with: export OLLAMA_ORIGINS=* &amp;&amp; ollama serve\n3. Or set environment: echo \'export OLLAMA_ORIGINS="*"\' &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc';
                  } else {
                     errorMessage = `Error: ${error.message}`;
                  }
                  await this.showNotification('error', 'Connection Failed', errorMessage);
               }

               testBtn.textContent = originalText;
               testBtn.disabled = false;
               this.updateConnectionDiagnostics();
            }

            /**
             * Saves settings from the modal form with validation/clamping.
             * Updates inputs to clamped values and reloads models.
             */
            async saveSettingsFromModal() {
               const ollamaUrl = document.getElementById('ollamaUrl').value;
               let temperature = parseFloat(document.getElementById('temperature').value);
               let topP = parseFloat(document.getElementById('topP').value);

               // Clamp and validate temperature (0-2)
               if (isNaN(temperature)) {
                  temperature = 0.7; // default
               } else {
                  temperature = Math.max(0, Math.min(2, temperature));
               }

               // Clamp and validate topP (0-1)
               if (isNaN(topP)) {
                  topP = 0.9; // default
               } else {
                  topP = Math.max(0, Math.min(1, topP));
               }

               // Update input values to clamped values for UI consistency
               document.getElementById('temperature').value = temperature;
               document.getElementById('topP').value = topP;

               const newSettings = { ollamaUrl, temperature, topP };
               await this.saveSettings(newSettings);
               this.hideSettings();
               await this.loadModels();
               await this.showNotification('success', 'Settings Saved', 'Your settings have been saved successfully');
            }
            /**
             * Sets up all event listeners for UI interactions (inputs, buttons, modals, etc.).
             */
            setupEventListeners() {
               const messageInput = document.getElementById('messageInput');
               const modelSelect = document.getElementById('modelSelect');
               const sendBtn = document.getElementById('sendBtn');
               const newChatBtn = document.getElementById('newChatBtn');
               const clearChatBtn = document.getElementById('clearChatBtn');
               const settingsBtn = document.getElementById('settingsBtn');
               const settingsModal = document.getElementById('settingsModal');
               const cancelSettingsBtn = document.getElementById('cancelSettingsBtn');
               const saveSettingsBtn = document.getElementById('saveSettingsBtn');
               const testConnectionBtn = document.getElementById('testConnectionBtn');
               const addModelBtn = document.getElementById('addModelBtn');
               const addModelInput = document.getElementById('addModelInput');
               const terminalClose = document.getElementById('terminalClose');
               const sidebarToggle = document.getElementById('sidebarToggle');
               const sidebar = document.getElementById('sidebar');
               const themeToggle = document.getElementById('themeToggle');
               const chatList = document.getElementById('chatList');

               // Handle message input submission (Enter key)
               this.addTrackedEventListener(messageInput, 'keydown', (e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                     e.preventDefault();
                     if (this.state.isStreaming) {
                        this.stopStreaming();
                     } else {
                        this.sendMessage();
                     }
                  }
               });

               // Auto-resize message input as user types
               this.addTrackedEventListener(messageInput, 'input', () => {
                  this.autoResize(messageInput);
               });

               // Handle model selection changes
               this.addTrackedEventListener(modelSelect, 'change', async (e) => {
                  this.state.selectedModel = e.target.value;
                  await this.saveAppState('selectedModel', e.target.value);
                  this.updateUI();
               });

               // Handle send/stop button clicks
               this.addTrackedEventListener(sendBtn, 'click', () => {
                  if (this.state.isStreaming) {
                     this.stopStreaming();
                  } else {
                     this.sendMessage();
                  }
               });

               // Handle new chat button clicks
               this.addTrackedEventListener(newChatBtn, 'click', () => {
                  this.createNewChat();
               });

               // Handle clear chat button clicks
               this.addTrackedEventListener(clearChatBtn, 'click', () => {
                  this.clearChat();
               });

               // Handle settings button clicks
               this.addTrackedEventListener(settingsBtn, 'click', () => {
                  this.showSettings();
               });

               // Handle cancel settings button clicks
               this.addTrackedEventListener(cancelSettingsBtn, 'click', () => {
                  this.hideSettings();
               });

               // Handle save settings button clicks
               this.addTrackedEventListener(saveSettingsBtn, 'click', () => {
                  this.saveSettingsFromModal();
               });

               // Handle test connection button clicks
               this.addTrackedEventListener(testConnectionBtn, 'click', () => {
                  this.testConnection();
               });

               // Handle add model button clicks
               this.addTrackedEventListener(addModelBtn, 'click', () => {
                  const modelName = addModelInput.value.trim();
                  this.pullModel(modelName);
               });

               // Handle Enter key in add model input
               this.addTrackedEventListener(addModelInput, 'keydown', (e) => {
                  if (e.key === 'Enter') {
                     e.preventDefault();
                     const modelName = addModelInput.value.trim();
                     this.pullModel(modelName);
                  }
               });

               // Handle terminal close button clicks
               this.addTrackedEventListener(terminalClose, 'click', () => {
                  document.getElementById('terminal').classList.remove('visible');
               });

               // Handle clicking outside settings modal to close it
               this.addTrackedEventListener(settingsModal, 'click', (e) => {
                  if (e.target === settingsModal) {
                     this.hideSettings();
                  }
               });

               // Handle sidebar toggle for mobile
               this.addTrackedEventListener(sidebarToggle, 'click', () => {
                  sidebar.classList.toggle('open');
               });

               // Handle theme toggle button clicks
               this.addTrackedEventListener(themeToggle, 'click', () => {
                  this.toggleTheme();
               });

               // Handle clicking outside sidebar to close it on mobile
               this.addTrackedEventListener(document, 'click', (e) => {
                  if (
                     window.innerWidth <= 768 &&
                     !sidebar.contains(e.target) &&
                     !sidebarToggle.contains(e.target)
                  ) {
                     sidebar.classList.remove('open');
                  }
               });

               // Use event delegation for chat list items
               this.addTrackedEventListener(chatList, 'click', (e) => {
                  const chatItem = e.target.closest('.chat-item');
                  if (chatItem) {
                     const chatId = chatItem.dataset.chatId;
                     if (e.target.classList.contains('chat-delete')) {
                        e.stopPropagation();
                        this.deleteChatHandler(chatId);
                     } else {
                        this.selectChat(chatId);
                     }
                  }
               });
            }
            /**
             * Initializes the application: DB, settings, chats, session restore, models, events, UI.
             * Handles errors gracefully with fallback.
             */
            async init() {
               try {
                  this.showLoading('Initializing application...');
                  this.showLoading('Setting up database...');
                  await this.initDB();

                  this.showLoading('Loading settings...');
                  await this.loadSettings();

                  this.showLoading('Loading your chats...');
                  await this.loadChats();

                  this.showLoading('Restoring session...');
                  const lastModel = await this.loadAppState('selectedModel');
                  const lastChatId = await this.loadAppState('currentChatId');

                  if (lastModel) this.state.selectedModel = lastModel;
                  if (lastChatId && this.state.chats[lastChatId]) {
                     this.state.currentChatId = lastChatId;
                  }

                  this.showLoading('Connecting to Ollama...');
                  await this.loadModels();

                  this.setupEventListeners();
                  this.updateUI();
                  this.hideLoading();
               } catch (error) {
                  console.error('Failed to initialize app:', error);
                  this.hideLoading();
                  await this.showNotification(
                     'error',
                     'Initialization Failed',
                     'Failed to initialize application. Some features may not work properly.'
                  );
                  await this.loadModels();
                  this.setupEventListeners();
                  this.updateUI();
               }
            }
         }

         const app = new OllamaChatApp();
         app.init();
      </script>
   </body>
</html>
